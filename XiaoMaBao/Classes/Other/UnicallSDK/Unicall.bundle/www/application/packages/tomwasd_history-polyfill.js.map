{"version":3,"sources":["meteor://ðŸ’»app/packages/tomwasd_history-polyfill/HTML5-History-API/history.js","meteor://ðŸ’»app/packages/tomwasd_history-polyfill/settings.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACljCA;AACA;AACA;AACA,0H","file":"/packages/tomwasd_history-polyfill.js","sourcesContent":["/*!\n * History API JavaScript Library v4.2.2\n *\n * Support: IE8+, FF3+, Opera 9+, Safari, Chrome and other\n *\n * Copyright 2011-2015, Dmitrii Pakhtinov ( spb.piksel@gmail.com )\n *\n * http://spb-piksel.ru/\n *\n * Dual licensed under the MIT and GPL licenses:\n *   http://www.opensource.org/licenses/mit-license.php\n *   http://www.gnu.org/licenses/gpl.html\n *\n * Update: 2015-06-26 23:22\n */\n(function(factory) {\n    if (typeof define === 'function' && define['amd']) {\n        // https://github.com/devote/HTML5-History-API/issues/73\n        var rndKey = '[history' + (new Date()).getTime() + ']';\n        var onError = requirejs['onError'];\n        factory.toString = function() {\n          return rndKey;\n        };\n        requirejs['onError'] = function(err) {\n          if (err.message.indexOf(rndKey) === -1) {\n            onError.call(requirejs, err);\n          }\n        };\n        define([], factory);\n    }\n    // commonJS support\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n      module['exports'] = factory();\n    } else {\n      // execute anyway\n      return factory();\n    }\n})(function() {\n    // Define global variable\n    var global = (typeof window === 'object' ? window : this) || {};\n    // Prevent the code from running if there is no window.history object or library already loaded\n    if (!global.history || \"emulate\" in global.history) return global.history;\n    // symlink to document\n    var document = global.document;\n    // HTML element\n    var documentElement = document.documentElement;\n    // symlink to constructor of Object\n    var Object = global['Object'];\n    // symlink to JSON Object\n    var JSON = global['JSON'];\n    // symlink to instance object of 'Location'\n    var windowLocation = global.location;\n    // symlink to instance object of 'History'\n    var windowHistory = global.history;\n    // new instance of 'History'. The default is a reference to the original object instance\n    var historyObject = windowHistory;\n    // symlink to method 'history.pushState'\n    var historyPushState = windowHistory.pushState;\n    // symlink to method 'history.replaceState'\n    var historyReplaceState = windowHistory.replaceState;\n    // if the browser supports HTML5-History-API\n    var isSupportHistoryAPI = !!historyPushState;\n    // verifies the presence of an object 'state' in interface 'History'\n    var isSupportStateObjectInHistory = 'state' in windowHistory;\n    // symlink to method 'Object.defineProperty'\n    var defineProperty = Object.defineProperty;\n    // new instance of 'Location', for IE8 will use the element HTMLAnchorElement, instead of pure object\n    var locationObject = redefineProperty({}, 't') ? {} : document.createElement('a');\n    // prefix for the names of events\n    var eventNamePrefix = '';\n    // String that will contain the name of the method\n    var addEventListenerName = global.addEventListener ? 'addEventListener' : (eventNamePrefix = 'on') && 'attachEvent';\n    // String that will contain the name of the method\n    var removeEventListenerName = global.removeEventListener ? 'removeEventListener' : 'detachEvent';\n    // String that will contain the name of the method\n    var dispatchEventName = global.dispatchEvent ? 'dispatchEvent' : 'fireEvent';\n    // reference native methods for the events\n    var addEvent = global[addEventListenerName];\n    var removeEvent = global[removeEventListenerName];\n    var dispatch = global[dispatchEventName];\n    // default settings\n    var currentPath = (window.location.pathname+'/').replace('//','/');\n    var settings = {\"basepath\": currentPath, \"redirect\": 0, \"type\": '/', \"init\": 0};\n    // key for the sessionStorage\n    var sessionStorageKey = '__historyAPI__';\n    // Anchor Element for parseURL function\n    var anchorElement = document.createElement('a');\n    // last URL before change to new URL\n    var lastURL = windowLocation.href;\n    // Control URL, need to fix the bug in Opera\n    var checkUrlForPopState = '';\n    // for fix on Safari 8\n    var triggerEventsInWindowAttributes = 1;\n    // trigger event 'onpopstate' on page load\n    var isFireInitialState = false;\n    // if used history.location of other code\n    var isUsedHistoryLocationFlag = 0;\n    // store a list of 'state' objects in the current session\n    var stateStorage = {};\n    // in this object will be stored custom handlers\n    var eventsList = {};\n    // stored last title\n    var lastTitle = document.title;\n\n    /**\n     * Properties that will be replaced in the global\n     * object 'window', to prevent conflicts\n     *\n     * @type {Object}\n     */\n    var eventsDescriptors = {\n        \"onhashchange\": null,\n        \"onpopstate\": null\n    };\n\n    /**\n     * Fix for Chrome in iOS\n     * See https://github.com/devote/HTML5-History-API/issues/29\n     */\n    var fastFixChrome = function(method, args) {\n        var isNeedFix = global.history !== windowHistory;\n        if (isNeedFix) {\n            global.history = windowHistory;\n        }\n        method.apply(windowHistory, args);\n        if (isNeedFix) {\n            global.history = historyObject;\n        }\n    };\n\n    /**\n     * Properties that will be replaced/added to object\n     * 'window.history', includes the object 'history.location',\n     * for a complete the work with the URL address\n     *\n     * @type {Object}\n     */\n    var historyDescriptors = {\n        /**\n         * Setting library initialization\n         *\n         * @param {null|String} [basepath] The base path to the site; defaults to the root \"/\".\n         * @param {null|String} [type] Substitute the string after the anchor; by default \"/\".\n         * @param {null|Boolean} [redirect] Enable link translation.\n         */\n        \"setup\": function(basepath, type, redirect) {\n            settings[\"basepath\"] = ('' + (basepath == null ? settings[\"basepath\"] : basepath))\n                .replace(/(?:^|\\/)[^\\/]*$/, '/');\n            settings[\"type\"] = type == null ? settings[\"type\"] : type;\n            settings[\"redirect\"] = redirect == null ? settings[\"redirect\"] : !!redirect;\n        },\n        /**\n         * @namespace history\n         * @param {String} [type]\n         * @param {String} [basepath]\n         */\n        \"redirect\": function(type, basepath) {\n            historyObject['setup'](basepath, type);\n            basepath = settings[\"basepath\"];\n            if (global.top == global.self) {\n                var relative = parseURL(null, false, true)._relative;\n                var path = windowLocation.pathname + windowLocation.search;\n                if (isSupportHistoryAPI) {\n                    path = path.replace(/([^\\/])$/, '$1/');\n                    if (relative != basepath && (new RegExp(\"^\" + basepath + \"$\", \"i\")).test(path)) {\n                        windowLocation.replace(relative);\n                    }\n                } else if (path != basepath) {\n                    path = path.replace(/([^\\/])\\?/, '$1/?');\n                    if ((new RegExp(\"^\" + basepath, \"i\")).test(path)) {\n                        windowLocation.replace(basepath + '#' + path.\n                            replace(new RegExp(\"^\" + basepath, \"i\"), settings[\"type\"]) + windowLocation.hash);\n                    }\n                }\n            }\n        },\n        /**\n         * The method adds a state object entry\n         * to the history.\n         *\n         * @namespace history\n         * @param {Object} state\n         * @param {string} title\n         * @param {string} [url]\n         */\n        pushState: function(state, title, url) {\n            var t = document.title;\n            if (lastTitle != null) {\n                document.title = lastTitle;\n            }\n            historyPushState && fastFixChrome(historyPushState, arguments);\n            changeState(state, url);\n            document.title = t;\n            lastTitle = title;\n        },\n        /**\n         * The method updates the state object,\n         * title, and optionally the URL of the\n         * current entry in the history.\n         *\n         * @namespace history\n         * @param {Object} state\n         * @param {string} title\n         * @param {string} [url]\n         */\n        replaceState: function(state, title, url) {\n            var t = document.title;\n            if (lastTitle != null) {\n                document.title = lastTitle;\n            }\n            delete stateStorage[windowLocation.href];\n            historyReplaceState && fastFixChrome(historyReplaceState, arguments);\n            changeState(state, url, true);\n            document.title = t;\n            lastTitle = title;\n        },\n        /**\n         * Object 'history.location' is similar to the\n         * object 'window.location', except that in\n         * HTML4 browsers it will behave a bit differently\n         *\n         * @namespace history\n         */\n        \"location\": {\n            set: function(value) {\n                if (isUsedHistoryLocationFlag === 0) isUsedHistoryLocationFlag = 1;\n                global.location = value;\n            },\n            get: function() {\n                if (isUsedHistoryLocationFlag === 0) isUsedHistoryLocationFlag = 1;\n                return isSupportHistoryAPI ? windowLocation : locationObject;\n            }\n        },\n        /**\n         * A state object is an object representing\n         * a user interface state.\n         *\n         * @namespace history\n         */\n        \"state\": {\n            get: function() {\n                return stateStorage[windowLocation.href] || null;\n            }\n        }\n    };\n\n    /**\n     * Properties for object 'history.location'.\n     * Object 'history.location' is similar to the\n     * object 'window.location', except that in\n     * HTML4 browsers it will behave a bit differently\n     *\n     * @type {Object}\n     */\n    var locationDescriptors = {\n        /**\n         * Navigates to the given page.\n         *\n         * @namespace history.location\n         */\n        assign: function(url) {\n            if (('' + url).indexOf('#') === 0) {\n                changeState(null, url);\n            } else {\n                windowLocation.assign(url);\n            }\n        },\n        /**\n         * Reloads the current page.\n         *\n         * @namespace history.location\n         */\n        reload: function() {\n            windowLocation.reload();\n        },\n        /**\n         * Removes the current page from\n         * the session history and navigates\n         * to the given page.\n         *\n         * @namespace history.location\n         */\n        replace: function(url) {\n            if (('' + url).indexOf('#') === 0) {\n                changeState(null, url, true);\n            } else {\n                windowLocation.replace(url);\n            }\n        },\n        /**\n         * Returns the current page's location.\n         *\n         * @namespace history.location\n         */\n        toString: function() {\n            return this.href;\n        },\n        /**\n         * Returns the current page's location.\n         * Can be set, to navigate to another page.\n         *\n         * @namespace history.location\n         */\n        \"href\": {\n            get: function() {\n                return parseURL()._href;\n            }\n        },\n        /**\n         * Returns the current page's protocol.\n         *\n         * @namespace history.location\n         */\n        \"protocol\": null,\n        /**\n         * Returns the current page's host and port number.\n         *\n         * @namespace history.location\n         */\n        \"host\": null,\n        /**\n         * Returns the current page's host.\n         *\n         * @namespace history.location\n         */\n        \"hostname\": null,\n        /**\n         * Returns the current page's port number.\n         *\n         * @namespace history.location\n         */\n        \"port\": null,\n        /**\n         * Returns the current page's path only.\n         *\n         * @namespace history.location\n         */\n        \"pathname\": {\n            get: function() {\n                return parseURL()._pathname;\n            }\n        },\n        /**\n         * Returns the current page's search\n         * string, beginning with the character\n         * '?' and to the symbol '#'\n         *\n         * @namespace history.location\n         */\n        \"search\": {\n            get: function() {\n                return parseURL()._search;\n            }\n        },\n        /**\n         * Returns the current page's hash\n         * string, beginning with the character\n         * '#' and to the end line\n         *\n         * @namespace history.location\n         */\n        \"hash\": {\n            set: function(value) {\n                changeState(null, ('' + value).replace(/^(#|)/, '#'), false, lastURL);\n            },\n            get: function() {\n                return parseURL()._hash;\n            }\n        }\n    };\n\n    /**\n     * Just empty function\n     *\n     * @return void\n     */\n    function emptyFunction() {\n        // dummy\n    }\n\n    /**\n     * Prepares a parts of the current or specified reference for later use in the library\n     *\n     * @param {string} [href]\n     * @param {boolean} [isWindowLocation]\n     * @param {boolean} [isNotAPI]\n     * @return {Object}\n     */\n    function parseURL(href, isWindowLocation, isNotAPI) {\n        var re = /(?:(\\w+\\:))?(?:\\/\\/(?:[^@]*@)?([^\\/:\\?#]+)(?::([0-9]+))?)?([^\\?#]*)(?:(\\?[^#]+)|\\?)?(?:(#.*))?/;\n        if (href != null && href !== '' && !isWindowLocation) {\n            var current = parseURL(),\n                base = document.getElementsByTagName('base')[0];\n            if (!isNotAPI && base && base.getAttribute('href')) {\n              // Fix for IE ignoring relative base tags.\n              // See http://stackoverflow.com/questions/3926197/html-base-tag-and-local-folder-path-with-internet-explorer\n              base.href = base.href;\n              current = parseURL(base.href, null, true);\n            }\n            var _pathname = current._pathname, _protocol = current._protocol;\n            // convert to type of string\n            href = '' + href;\n            // convert relative link to the absolute\n            href = /^(?:\\w+\\:)?\\/\\//.test(href) ? href.indexOf(\"/\") === 0\n                ? _protocol + href : href : _protocol + \"//\" + current._host + (\n                href.indexOf(\"/\") === 0 ? href : href.indexOf(\"?\") === 0\n                    ? _pathname + href : href.indexOf(\"#\") === 0\n                    ? _pathname + current._search + href : _pathname.replace(/[^\\/]+$/g, '') + href\n                );\n        } else {\n            href = isWindowLocation ? href : windowLocation.href;\n            // if current browser not support History-API\n            if (!isSupportHistoryAPI || isNotAPI) {\n                // get hash fragment\n                href = href.replace(/^[^#]*/, '') || \"#\";\n                // form the absolute link from the hash\n                // https://github.com/devote/HTML5-History-API/issues/50\n                href = windowLocation.protocol.replace(/:.*$|$/, ':') + '//' + windowLocation.host + settings['basepath']\n                    + href.replace(new RegExp(\"^#[\\/]?(?:\" + settings[\"type\"] + \")?\"), \"\");\n            }\n        }\n        // that would get rid of the links of the form: /../../\n        anchorElement.href = href;\n        // decompose the link in parts\n        var result = re.exec(anchorElement.href);\n        // host name with the port number\n        var host = result[2] + (result[3] ? ':' + result[3] : '');\n        // folder\n        var pathname = result[4] || '/';\n        // the query string\n        var search = result[5] || '';\n        // hash\n        var hash = result[6] === '#' ? '' : (result[6] || '');\n        // relative link, no protocol, no host\n        var relative = pathname + search + hash;\n        // special links for set to hash-link, if browser not support History API\n        var nohash = pathname.replace(new RegExp(\"^\" + settings[\"basepath\"], \"i\"), settings[\"type\"]) + search;\n        // result\n        return {\n            _href: result[1] + '//' + host + relative,\n            _protocol: result[1],\n            _host: host,\n            _hostname: result[2],\n            _port: result[3] || '',\n            _pathname: pathname,\n            _search: search,\n            _hash: hash,\n            _relative: relative,\n            _nohash: nohash,\n            _special: nohash + hash\n        }\n    }\n\n    /**\n     * Initializing storage for the custom state's object\n     */\n    function storageInitialize() {\n        var sessionStorage;\n        /**\n         * sessionStorage throws error when cookies are disabled\n         * Chrome content settings when running the site in a Facebook IFrame.\n         * see: https://github.com/devote/HTML5-History-API/issues/34\n         * and: http://stackoverflow.com/a/12976988/669360\n         */\n        try {\n            sessionStorage = global['sessionStorage'];\n            sessionStorage.setItem(sessionStorageKey + 't', '1');\n            sessionStorage.removeItem(sessionStorageKey + 't');\n        } catch(_e_) {\n            sessionStorage = {\n                getItem: function(key) {\n                    var cookie = document.cookie.split(key + \"=\");\n                    return cookie.length > 1 && cookie.pop().split(\";\").shift() || 'null';\n                },\n                setItem: function(key, value) {\n                    var state = {};\n                    // insert one current element to cookie\n                    if (state[windowLocation.href] = historyObject.state) {\n                        document.cookie = key + '=' + JSON.stringify(state);\n                    }\n                }\n            }\n        }\n\n        try {\n            // get cache from the storage in browser\n            stateStorage = JSON.parse(sessionStorage.getItem(sessionStorageKey)) || {};\n        } catch(_e_) {\n            stateStorage = {};\n        }\n\n        // hang up the event handler to event unload page\n        addEvent(eventNamePrefix + 'unload', function() {\n            // save current state's object\n            sessionStorage.setItem(sessionStorageKey, JSON.stringify(stateStorage));\n        }, false);\n    }\n\n    /**\n     * This method is implemented to override the built-in(native)\n     * properties in the browser, unfortunately some browsers are\n     * not allowed to override all the properties and even add.\n     * For this reason, this was written by a method that tries to\n     * do everything necessary to get the desired result.\n     *\n     * @param {Object} object The object in which will be overridden/added property\n     * @param {String} prop The property name to be overridden/added\n     * @param {Object} [descriptor] An object containing properties set/get\n     * @param {Function} [onWrapped] The function to be called when the wrapper is created\n     * @return {Object|Boolean} Returns an object on success, otherwise returns false\n     */\n    function redefineProperty(object, prop, descriptor, onWrapped) {\n        var testOnly = 0;\n        // test only if descriptor is undefined\n        if (!descriptor) {\n            descriptor = {set: emptyFunction};\n            testOnly = 1;\n        }\n        // variable will have a value of true the success of attempts to set descriptors\n        var isDefinedSetter = !descriptor.set;\n        var isDefinedGetter = !descriptor.get;\n        // for tests of attempts to set descriptors\n        var test = {configurable: true, set: function() {\n            isDefinedSetter = 1;\n        }, get: function() {\n            isDefinedGetter = 1;\n        }};\n\n        try {\n            // testing for the possibility of overriding/adding properties\n            defineProperty(object, prop, test);\n            // running the test\n            object[prop] = object[prop];\n            // attempt to override property using the standard method\n            defineProperty(object, prop, descriptor);\n        } catch(_e_) {\n        }\n\n        // If the variable 'isDefined' has a false value, it means that need to try other methods\n        if (!isDefinedSetter || !isDefinedGetter) {\n            // try to override/add the property, using deprecated functions\n            if (object.__defineGetter__) {\n                // testing for the possibility of overriding/adding properties\n                object.__defineGetter__(prop, test.get);\n                object.__defineSetter__(prop, test.set);\n                // running the test\n                object[prop] = object[prop];\n                // attempt to override property using the deprecated functions\n                descriptor.get && object.__defineGetter__(prop, descriptor.get);\n                descriptor.set && object.__defineSetter__(prop, descriptor.set);\n            }\n\n            // Browser refused to override the property, using the standard and deprecated methods\n            if (!isDefinedSetter || !isDefinedGetter) {\n                if (testOnly) {\n                    return false;\n                } else if (object === global) {\n                    // try override global properties\n                    try {\n                        // save original value from this property\n                        var originalValue = object[prop];\n                        // set null to built-in(native) property\n                        object[prop] = null;\n                    } catch(_e_) {\n                    }\n                    // This rule for Internet Explorer 8\n                    if ('execScript' in global) {\n                        /**\n                         * to IE8 override the global properties using\n                         * VBScript, declaring it in global scope with\n                         * the same names.\n                         */\n                        global['execScript']('Public ' + prop, 'VBScript');\n                        global['execScript']('var ' + prop + ';', 'JavaScript');\n                    } else {\n                        try {\n                            /**\n                             * This hack allows to override a property\n                             * with the set 'configurable: false', working\n                             * in the hack 'Safari' to 'Mac'\n                             */\n                            defineProperty(object, prop, {value: emptyFunction});\n                        } catch(_e_) {\n                            if (prop === 'onpopstate') {\n                                /**\n                                 * window.onpopstate fires twice in Safari 8.0.\n                                 * Block initial event on window.onpopstate\n                                 * See: https://github.com/devote/HTML5-History-API/issues/69\n                                 */\n                                addEvent('popstate', descriptor = function() {\n                                    removeEvent('popstate', descriptor, false);\n                                    var onpopstate = object.onpopstate;\n                                    // cancel initial event on attribute handler\n                                    object.onpopstate = null;\n                                    setTimeout(function() {\n                                      // restore attribute value after short time\n                                      object.onpopstate = onpopstate;\n                                    }, 1);\n                                }, false);\n                                // cancel trigger events on attributes in object the window\n                                triggerEventsInWindowAttributes = 0;\n                            }\n                        }\n                    }\n                    // set old value to new variable\n                    object[prop] = originalValue;\n\n                } else {\n                    // the last stage of trying to override the property\n                    try {\n                        try {\n                            // wrap the object in a new empty object\n                            var temp = Object.create(object);\n                            defineProperty(Object.getPrototypeOf(temp) === object ? temp : object, prop, descriptor);\n                            for(var key in object) {\n                                // need to bind a function to the original object\n                                if (typeof object[key] === 'function') {\n                                    temp[key] = object[key].bind(object);\n                                }\n                            }\n                            try {\n                                // to run a function that will inform about what the object was to wrapped\n                                onWrapped.call(temp, temp, object);\n                            } catch(_e_) {\n                            }\n                            object = temp;\n                        } catch(_e_) {\n                            // sometimes works override simply by assigning the prototype property of the constructor\n                            defineProperty(object.constructor.prototype, prop, descriptor);\n                        }\n                    } catch(_e_) {\n                        // all methods have failed\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     * Adds the missing property in descriptor\n     *\n     * @param {Object} object An object that stores values\n     * @param {String} prop Name of the property in the object\n     * @param {Object|null} descriptor Descriptor\n     * @return {Object} Returns the generated descriptor\n     */\n    function prepareDescriptorsForObject(object, prop, descriptor) {\n        descriptor = descriptor || {};\n        // the default for the object 'location' is the standard object 'window.location'\n        object = object === locationDescriptors ? windowLocation : object;\n        // setter for object properties\n        descriptor.set = (descriptor.set || function(value) {\n            object[prop] = value;\n        });\n        // getter for object properties\n        descriptor.get = (descriptor.get || function() {\n            return object[prop];\n        });\n        return descriptor;\n    }\n\n    /**\n     * Wrapper for the methods 'addEventListener/attachEvent' in the context of the 'window'\n     *\n     * @param {String} event The event type for which the user is registering\n     * @param {Function} listener The method to be called when the event occurs.\n     * @param {Boolean} capture If true, capture indicates that the user wishes to initiate capture.\n     * @return void\n     */\n    function addEventListener(event, listener, capture) {\n        if (event in eventsList) {\n            // here stored the event listeners 'popstate/hashchange'\n            eventsList[event].push(listener);\n        } else {\n            // FireFox support non-standart four argument aWantsUntrusted\n            // https://github.com/devote/HTML5-History-API/issues/13\n            if (arguments.length > 3) {\n                addEvent(event, listener, capture, arguments[3]);\n            } else {\n                addEvent(event, listener, capture);\n            }\n        }\n    }\n\n    /**\n     * Wrapper for the methods 'removeEventListener/detachEvent' in the context of the 'window'\n     *\n     * @param {String} event The event type for which the user is registered\n     * @param {Function} listener The parameter indicates the Listener to be removed.\n     * @param {Boolean} capture Was registered as a capturing listener or not.\n     * @return void\n     */\n    function removeEventListener(event, listener, capture) {\n        var list = eventsList[event];\n        if (list) {\n            for(var i = list.length; i--;) {\n                if (list[i] === listener) {\n                    list.splice(i, 1);\n                    break;\n                }\n            }\n        } else {\n            removeEvent(event, listener, capture);\n        }\n    }\n\n    /**\n     * Wrapper for the methods 'dispatchEvent/fireEvent' in the context of the 'window'\n     *\n     * @param {Event|String} event Instance of Event or event type string if 'eventObject' used\n     * @param {*} [eventObject] For Internet Explorer 8 required event object on this argument\n     * @return {Boolean} If 'preventDefault' was called the value is false, else the value is true.\n     */\n    function dispatchEvent(event, eventObject) {\n        var eventType = ('' + (typeof event === \"string\" ? event : event.type)).replace(/^on/, '');\n        var list = eventsList[eventType];\n        if (list) {\n            // need to understand that there is one object of Event\n            eventObject = typeof event === \"string\" ? eventObject : event;\n            if (eventObject.target == null) {\n                // need to override some of the properties of the Event object\n                for(var props = ['target', 'currentTarget', 'srcElement', 'type']; event = props.pop();) {\n                    // use 'redefineProperty' to override the properties\n                    eventObject = redefineProperty(eventObject, event, {\n                        get: event === 'type' ? function() {\n                            return eventType;\n                        } : function() {\n                            return global;\n                        }\n                    });\n                }\n            }\n            if (triggerEventsInWindowAttributes) {\n              // run function defined in the attributes 'onpopstate/onhashchange' in the 'window' context\n              ((eventType === 'popstate' ? global.onpopstate : global.onhashchange)\n                  || emptyFunction).call(global, eventObject);\n            }\n            // run other functions that are in the list of handlers\n            for(var i = 0, len = list.length; i < len; i++) {\n                list[i].call(global, eventObject);\n            }\n            return true;\n        } else {\n            return dispatch(event, eventObject);\n        }\n    }\n\n    /**\n     * dispatch current state event\n     */\n    function firePopState() {\n        var o = document.createEvent ? document.createEvent('Event') : document.createEventObject();\n        if (o.initEvent) {\n            o.initEvent('popstate', false, false);\n        } else {\n            o.type = 'popstate';\n        }\n        o.state = historyObject.state;\n        // send a newly created events to be processed\n        dispatchEvent(o);\n    }\n\n    /**\n     * fire initial state for non-HTML5 browsers\n     */\n    function fireInitialState() {\n        if (isFireInitialState) {\n            isFireInitialState = false;\n            firePopState();\n        }\n    }\n\n    /**\n     * Change the data of the current history for HTML4 browsers\n     *\n     * @param {Object} state\n     * @param {string} [url]\n     * @param {Boolean} [replace]\n     * @param {string} [lastURLValue]\n     * @return void\n     */\n    function changeState(state, url, replace, lastURLValue) {\n        if (!isSupportHistoryAPI) {\n            // if not used implementation history.location\n            if (isUsedHistoryLocationFlag === 0) isUsedHistoryLocationFlag = 2;\n            // normalization url\n            var urlObject = parseURL(url, isUsedHistoryLocationFlag === 2 && ('' + url).indexOf(\"#\") !== -1);\n            // if current url not equal new url\n            if (urlObject._relative !== parseURL()._relative) {\n                // if empty lastURLValue to skip hash change event\n                lastURL = lastURLValue;\n                if (replace) {\n                    // only replace hash, not store to history\n                    windowLocation.replace(\"#\" + urlObject._special);\n                } else {\n                    // change hash and add new record to history\n                    windowLocation.hash = urlObject._special;\n                }\n            }\n        } else {\n            lastURL = windowLocation.href;\n        }\n        if (!isSupportStateObjectInHistory && state) {\n            stateStorage[windowLocation.href] = state;\n        }\n        isFireInitialState = false;\n    }\n\n    /**\n     * Event handler function changes the hash in the address bar\n     *\n     * @param {Event} event\n     * @return void\n     */\n    function onHashChange(event) {\n        // https://github.com/devote/HTML5-History-API/issues/46\n        var fireNow = lastURL;\n        // new value to lastURL\n        lastURL = windowLocation.href;\n        // if not empty fireNow, otherwise skipped the current handler event\n        if (fireNow) {\n            // if checkUrlForPopState equal current url, this means that the event was raised popstate browser\n            if (checkUrlForPopState !== windowLocation.href) {\n                // otherwise,\n                // the browser does not support popstate event or just does not run the event by changing the hash.\n                firePopState();\n            }\n            // current event object\n            event = event || global.event;\n\n            var oldURLObject = parseURL(fireNow, true);\n            var newURLObject = parseURL();\n            // HTML4 browser not support properties oldURL/newURL\n            if (!event.oldURL) {\n                event.oldURL = oldURLObject._href;\n                event.newURL = newURLObject._href;\n            }\n            if (oldURLObject._hash !== newURLObject._hash) {\n                // if current hash not equal previous hash\n                dispatchEvent(event);\n            }\n        }\n    }\n\n    /**\n     * The event handler is fully loaded document\n     *\n     * @param {*} [noScroll]\n     * @return void\n     */\n    function onLoad(noScroll) {\n        // Get rid of the events popstate when the first loading a document in the webkit browsers\n        setTimeout(function() {\n            // hang up the event handler for the built-in popstate event in the browser\n            addEvent('popstate', function(e) {\n                // set the current url, that suppress the creation of the popstate event by changing the hash\n                checkUrlForPopState = windowLocation.href;\n                // for Safari browser in OS Windows not implemented 'state' object in 'History' interface\n                // and not implemented in old HTML4 browsers\n                if (!isSupportStateObjectInHistory) {\n                    e = redefineProperty(e, 'state', {get: function() {\n                        return historyObject.state;\n                    }});\n                }\n                // send events to be processed\n                dispatchEvent(e);\n            }, false);\n        }, 0);\n        // for non-HTML5 browsers\n        if (!isSupportHistoryAPI && noScroll !== true && \"location\" in historyObject) {\n            // scroll window to anchor element\n            scrollToAnchorId(locationObject.hash);\n            // fire initial state for non-HTML5 browser after load page\n            fireInitialState();\n        }\n    }\n\n    /**\n     * Finds the closest ancestor anchor element (including the target itself).\n     *\n     * @param {HTMLElement} target The element to start scanning from.\n     * @return {HTMLElement} An element which is the closest ancestor anchor.\n     */\n    function anchorTarget(target) {\n        while (target) {\n            if (target.nodeName === 'A') return target;\n            target = target.parentNode;\n        }\n    }\n\n    /**\n     * Handles anchor elements with a hash fragment for non-HTML5 browsers\n     *\n     * @param {Event} e\n     */\n    function onAnchorClick(e) {\n        var event = e || global.event;\n        var target = anchorTarget(event.target || event.srcElement);\n        var defaultPrevented = \"defaultPrevented\" in event ? event['defaultPrevented'] : event.returnValue === false;\n        if (target && target.nodeName === \"A\" && !defaultPrevented) {\n            var current = parseURL();\n            var expect = parseURL(target.getAttribute(\"href\", 2));\n            var isEqualBaseURL = current._href.split('#').shift() === expect._href.split('#').shift();\n            if (isEqualBaseURL && expect._hash) {\n                if (current._hash !== expect._hash) {\n                    locationObject.hash = expect._hash;\n                }\n                scrollToAnchorId(expect._hash);\n                if (event.preventDefault) {\n                    event.preventDefault();\n                } else {\n                    event.returnValue = false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Scroll page to current anchor in url-hash\n     *\n     * @param hash\n     */\n    function scrollToAnchorId(hash) {\n        var target = document.getElementById(hash = (hash || '').replace(/^#/, ''));\n        if (target && target.id === hash && target.nodeName === \"A\") {\n            var rect = target.getBoundingClientRect();\n            global.scrollTo((documentElement.scrollLeft || 0), rect.top + (documentElement.scrollTop || 0)\n                - (documentElement.clientTop || 0));\n        }\n    }\n\n    /**\n     * Library initialization\n     *\n     * @return {Boolean} return true if all is well, otherwise return false value\n     */\n    function initialize() {\n        /**\n         * Get custom settings from the query string\n         */\n        var scripts = document.getElementsByTagName('script');\n        var src = (scripts[scripts.length - 1] || {}).src || '';\n        var arg = src.indexOf('?') !== -1 ? src.split('?').pop() : '';\n        arg.replace(/(\\w+)(?:=([^&]*))?/g, function(a, key, value) {\n            settings[key] = (value || '').replace(/^(0|false)$/, '');\n        });\n\n        /**\n         * hang up the event handler to listen to the events hashchange\n         */\n        addEvent(eventNamePrefix + 'hashchange', onHashChange, false);\n\n        // a list of objects with pairs of descriptors/object\n        var data = [locationDescriptors, locationObject, eventsDescriptors, global, historyDescriptors, historyObject];\n\n        // if browser support object 'state' in interface 'History'\n        if (isSupportStateObjectInHistory) {\n            // remove state property from descriptor\n            delete historyDescriptors['state'];\n        }\n\n        // initializing descriptors\n        for(var i = 0; i < data.length; i += 2) {\n            for(var prop in data[i]) {\n                if (data[i].hasOwnProperty(prop)) {\n                    if (typeof data[i][prop] === 'function') {\n                        // If the descriptor is a simple function, simply just assign it an object\n                        data[i + 1][prop] = data[i][prop];\n                    } else {\n                        // prepare the descriptor the required format\n                        var descriptor = prepareDescriptorsForObject(data[i], prop, data[i][prop]);\n                        // try to set the descriptor object\n                        if (!redefineProperty(data[i + 1], prop, descriptor, function(n, o) {\n                            // is satisfied if the failed override property\n                            if (o === historyObject) {\n                                // the problem occurs in Safari on the Mac\n                                global.history = historyObject = data[i + 1] = n;\n                            }\n                        })) {\n                            // if there is no possibility override.\n                            // This browser does not support descriptors, such as IE7\n\n                            // remove previously hung event handlers\n                            removeEvent(eventNamePrefix + 'hashchange', onHashChange, false);\n\n                            // fail to initialize :(\n                            return false;\n                        }\n\n                        // create a repository for custom handlers onpopstate/onhashchange\n                        if (data[i + 1] === global) {\n                            eventsList[prop] = eventsList[prop.substr(2)] = [];\n                        }\n                    }\n                }\n            }\n        }\n\n        // check settings\n        historyObject['setup']();\n\n        // redirect if necessary\n        if (settings['redirect']) {\n            historyObject['redirect']();\n        }\n\n        // initialize\n        if (settings[\"init\"]) {\n            // You agree that you will use window.history.location instead window.location\n            isUsedHistoryLocationFlag = 1;\n        }\n\n        // If browser does not support object 'state' in interface 'History'\n        if (!isSupportStateObjectInHistory && JSON) {\n            storageInitialize();\n        }\n\n        // track clicks on anchors\n        if (!isSupportHistoryAPI) {\n            document[addEventListenerName](eventNamePrefix + \"click\", onAnchorClick, false);\n        }\n\n        if (document.readyState === 'complete') {\n            onLoad(true);\n        } else {\n            if (!isSupportHistoryAPI && parseURL()._relative !== settings[\"basepath\"]) {\n                isFireInitialState = true;\n            }\n            /**\n             * Need to avoid triggering events popstate the initial page load.\n             * Hang handler popstate as will be fully loaded document that\n             * would prevent triggering event onpopstate\n             */\n            addEvent(eventNamePrefix + 'load', onLoad, false);\n        }\n\n        // everything went well\n        return true;\n    }\n\n    /**\n     * Starting the library\n     */\n    if (!initialize()) {\n        // if unable to initialize descriptors\n        // therefore quite old browser and there\n        // is no sense to continue to perform\n        return;\n    }\n\n    /**\n     * If the property history.emulate will be true,\n     * this will be talking about what's going on\n     * emulation capabilities HTML5-History-API.\n     * Otherwise there is no emulation, ie the\n     * built-in browser capabilities.\n     *\n     * @type {boolean}\n     * @const\n     */\n    historyObject['emulate'] = !isSupportHistoryAPI;\n\n    /**\n     * Replace the original methods on the wrapper\n     */\n    global[addEventListenerName] = addEventListener;\n    global[removeEventListenerName] = removeEventListener;\n    global[dispatchEventName] = dispatchEvent;\n\n    return historyObject;\n});\n","// Make sure that polyfilled links are redirected to correct links in \n// supporting browsers. Enables sharing links between IE and non-IE\n// e.g. http://example.com/#/some-path -> http://example.com/some-path\nhistory.redirect();"]}